/* For copyright information please refer to files in the COPYRIGHT directory
 */
#include "irods_hashtable.h"
#include <cstdlib>
//#include "utils.hpp"
/**
 * Allocated dynamically
 * returns NULL if out of memory
 */

static char *cpStringExtForHashTable( const char *str, Region *r ) {
    char *strCp = ( char * )region_alloc( r, ( strlen( str ) + 1 ) * sizeof( char ) );
    strcpy( strCp, str );
    return strCp;
}


struct bucket *newBucket( const char* key, const void* value ) {
    struct bucket *b = ( struct bucket * )malloc( sizeof( struct bucket ) );
    if ( b == NULL ) {
        return NULL;
    }
    b->next = NULL;
    b->key = strdup( key );
    b->value = value;
    return b;
}

/**
 * Allocated in regions
 */
struct bucket *newBucket2( char* key, const void* value, Region *r ) {
    struct bucket *b = ( struct bucket * )region_alloc( r, sizeof( struct bucket ) );
    if ( b == NULL ) {
        return NULL;
    }
    b->next = NULL;
    b->key = key;
    b->value = value;
    return b;
}

/**
 * hashtable with dynamic expansion
 * returns NULL if out of memory
 */
Hashtable *newHashTable2( int size, Region *r ) {

    Hashtable *h = ( Hashtable * )region_alloc( r, sizeof( Hashtable ) );
    if ( NULL == h ) { // JMC cppcheck - nullptr ref
        return 0;
    }
    memset( h, 0, sizeof( Hashtable ) );

//	if(h==NULL) {
//		return NULL;
//	}
    h->dynamic = 1;
    h->bucketRegion = r;
    h->size = size;
    h->buckets = ( struct bucket ** )region_alloc( h->bucketRegion, sizeof( struct bucket * ) * size );
    if ( h->buckets == NULL ) {
        return NULL;
    }
    memset( h->buckets, 0, sizeof( struct bucket * )*size );
    h->len = 0;
    return h;
}
/**
 * the key is duplicated but the value is not duplicated.
 * MM: the key is managed by hashtable while the value is managed by the caller.
 * returns 0 if out of memory
 */
int insertIntoHashTable( Hashtable *h, const char* key, const void *value ) {
    /*
        printf("insert %s=%s\n", key, value==NULL?"null":"<value>");
    */
    if ( h->dynamic ) {
        if ( h->len >= h->size ) {
            Hashtable *h2 = newHashTable2( h->size * 2, h->bucketRegion );
            int i;
            for ( i = 0; i < h->size; i++ ) {
                if ( h->buckets[i] != NULL ) {
                    struct bucket *b = h->buckets[i];
                    do {
                        insertIntoHashTable( h2, b->key, b->value );
                        b = b->next;

                    }
                    while ( b != NULL );
                }
            }
            memcpy( h, h2, sizeof( Hashtable ) );
        }
        struct bucket *b = newBucket2( cpStringExtForHashTable( key, h->bucketRegion ), value, h->bucketRegion );
        if ( b == NULL ) {
            return 0;
        }

        unsigned long hs = myhash( key );
        unsigned long index = hs % h->size;
        if ( h->buckets[index] == NULL ) {
            h->buckets[index] = b;
        }
        else {
            struct bucket *b0 = h->buckets[index];
            while ( b0->next != NULL ) {
                b0 = b0->next;
            }
            b0->next = b;
        }
        h->len ++;
        return 1;
    }
    else {
        struct bucket *b = newBucket( key, value );
        if ( b == NULL ) {
            return 0;
        }
        unsigned long hs = myhash( key );
        unsigned long index = hs % h->size;
        if ( h->buckets[index] == NULL ) {
            h->buckets[index] = b;
        }
        else {
            struct bucket *b0 = h->buckets[index];
            while ( b0->next != NULL ) {
                b0 = b0->next;
            }
            b0->next = b;
        }
        h->len ++;
        return 1;
    }
}

void deleteBucket( struct bucket *b0, void ( *f )( const void * ) ) {
    if ( b0->next != NULL ) {
        deleteBucket( b0->next, f );
    }
    /* todo do not delete keys if they are allocated in regions */
    free( b0->key );
    if ( f != NULL ) {
        f( b0->value );
    }
    free( b0 );
}

